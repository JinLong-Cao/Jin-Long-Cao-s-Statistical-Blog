---
title: "Problem Set 3"
author: "John Cao, Brian Diep, Jonathan Tillmann, Tanya Woloshansky"
date: "19/10/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#install.packages('brm')
#install.packages('rstan')
#install.packages('tidyverse')
#install.packages('rtools')
#install.packages('fastmatch')
library(fastmatch)
library(brms)
library(rstan)
library(tidyverse)
gss <- read.csv("gss.csv")

```
## Abstract

   Inequality and sexism have historically shaped Canadian society and the lives of the many individuals who comprise it. Although contemporary Canada ranks well in terms of gender equality, there is still room for much improvement. We can quantify gender inequality by measuring the socioeconomic conditions of various men and women. Through our analysis of data gathered from the Canadian General Social Survey, our findings suggest that gender inequality persists within Canadian society and particularly in [plug results].
   
## Introduction

  Canada is a country that prides itself on having a high level of social equality between men and women. This is a justified belief in many regards, Canada ranks well among OECD countries in terms of gender equality in several key metrics such as workforce participation and higher education attainment (OECD, 2017). In more recent years, the federal government under Justin Trudeau has also positioned himself and his cabinet as a force to promote feminism within Canada as well as abroad (Gerster, 2019). However, this only emphasizes the fact that we must reflect upon the status of gender equality within Canada, especially when we continue to see shortcomings and inequality manifesting itself within different sectors of society. The following report seeks to provide an analysis of Canadian gender inequality by drawing upon data from the Canadian General Social Survey (GSS). We focus on socioeconomic indicators such as employment statistics and educational attainment to find correlations between an individual's sex and their quality of life. Based on our findings we propose a few areas of improvement that are necessary to close the gender gap in Canada.

## Data

  The dataset we used for our analysis came from responses to Statistics Canada's General Social Survey (GSS). The survey currently has six themes that are cycled through approximately every five years. We decided to look at the survey conducted in 2017 on the theme of Family. The survey was conducted via telephone, specifically by random digit dialing in which phone numbers are generated randomly based on in-use area codes (the numbers generated were specifically for landlines). Respondents were assured confidentiality under the authority of the Statistics Act. Interviews were given until reaching a sample size of 25000 respondents. The dataset we specifically used was generously provided by UofT Prof. Alexander and had 20602 respondents after incomplete interviews were removed. 

  The target population of the study were citizens in Canada aged fifteen-plus living in private households. The sampling frame of the study was the list of randomly generated phone numbers. The telephone interviews were carried out with Computer Assisted Telephone Interviewing to lower costs. The random digit dialing method carried out allowed Statistics Canada to reach unlisted phone numbers, avoiding the problem of missing the demographic when using pre-existing telephone lists. However, their data collection method excludes cell phone only households and those without landlines. Therefore, certain demographics are less likely to be sampled like younger homeowners and lower income households respectively. The survey also overrepresented elderly citizens that are in retirement age due to the nature of having more spare time than a working individual and more willing to answer a 45 minute interview.  Conducting the survey via telephone also lowered response rates compared to a face-to-face interview and limited the questions that could be asked. 

Figure Data (Subsection specific for doc, dont include subsection title in report)

```{r Age Groups, echo=FALSE}

gss %>% 
  mutate(is_male = ifelse(sex=="Male", 0, 1))

#Plot demonstrating the skew in the average age of respondents
hist(gss$age, 
      main="Figure 1. Frequency of Canadian GSS Respondent Ages", 
      xlab="Age of Respondents", 
      border="white", 
      col="cadetblue4",
      cex.main=0.75)
```

  Figure 1 above demonstrates a right skew with the age distribution of respondents leaning to ages fifty-plus making up the majority. This can be explained due to the lower coverage of younger homeowners without landlines and overrepresentation of retirement aged individuals.

```{r money_stats, echo=FALSE}
gss %>% 
  mutate(is_male = ifelse(sex=="Male", 0, 1))

avg_hrs_worked_rank = fmatch(gss$average_hours_worked, c("NA", "Don't know", "0.1 to 29.9 hours", "30.0 to 40.0 hours", "40.1 to 50.0 hours", "50.1 hours and more"))

income_family_rank = fmatch(gss$income_family, c("Less than $25,000", "$25,000 to $49,999", "$50,000 to $74,999", "$75,000 to $99,999", "$100,000 to $ 124,999", "$125,000 and more"))

income_respondent_rank = fmatch(gss$income_respondent, c("Less than $25,000", "$25,000 to $49,999", "$50,000 to $74,999", "$75,000 to $99,999", "$100,000 to $ 124,999", "$125,000 and more"))

#Plot demonstrating the skew in the average age of respondents

gss %>%  
ggplot(aes(x = Travel_Within_Canada)) +
  geom_bar(colour ="black", fill="steelblue") +
  labs(x = "Response",
       y = "Frequency",
       title = "Figure 3.5: 'Have you travelled within Canada within the past 6 months?'") +
  theme(panel.background = element_rect(fill = "lightblue",
                                colour = "lightblue",
                                size = 0.5, linetype = "solid"))
```

  This figure showcasing the distribution of respondents' family income demonstrates non-coverage of lower income households lacking a landline. The median income of a family after taxes in Canada is $61 400 (Statistics Canada 2020), however our figure shows a significant portion of respondents reporting family incomes of over $125 000. 

  This figure modeling the distribution of respondents' individual income demonstrates a left skew leaning towards a low individual income in contrast to figure (replace with figure number of respondents' family income). This can be explained due to the overrepresentation of elderly individuals in retirement age that cause lower income responses to make up the majority while maintaining a high family income.
  
```{r filter, echo=FALSE}
gss2 <-gss
gss2$sex<- ifelse(gss2$sex=="Male",1,0)
```

```{r sdafjlka, echo=FALSE}
#Filter men/women into separate tables

fem <- filter(gss2, sex == 0)
men <- filter(gss2, sex == 1)

```

```{r female_occupation, echo=FALSE}
#Create Pie Chart of Female Occupations With Percentages
focc_table<-table(fem$occupation)
labels=c("Business and Finance", "Health", NA, "Management", "Sciences", "Resources/Agriculture", "Art, Culture, Recreation", "Social Work, Education, Law", "Manufacturing and Ultilities", "Sales or Service", "Trades, Transport", "Uncoded")
pct <- round(focc_table/sum(focc_table)*100)
occu_lbl<- paste(labels, pct)
occu_lbl <- paste(occu_lbl,"%",sep="")
pie(focc_table,labels = occu_lbl, col=rainbow(length(occu_lbl)), main="Careers Proportions of Female Respondents", radius = 1.0)

```
```{r male_occupation, echo=FALSE}
#Create Pie Chart of Male Occupations With Percentages
mocc_table<-table(men$occupation)
labels=c("Business and Finance", "Health", NA, "Management", "Sciences", "Resources/Agriculture", "Art, Culture, Recreation", "Social Work, Education, Law", "Manufacturing and Ultilities", "Sales or Service", "Trades, Transport", "Uncoded")
pctm <- round(mocc_table/sum(mocc_table)*100)
moccu_lbl<- paste(labels, pctm)
moccu_lbl <- paste(moccu_lbl,"%",sep="")
pie(mocc_table,labels = moccu_lbl, col=rainbow(length(moccu_lbl)), main="Careers Proportions of Male Respondents")

```


## Model

  A logistic model was used to model the data for our analysis of how sex affects one's socioeconomic status. Logistic models are generally used when trying to model the associations found between various independent variables and binary categorical dependent variables. Mathematically this takes the form of  we can express the probability 'p' as a logarithmic function of the various dependent variables.

equation for log(p/ 1-p) = beta0 + beta1x1 + beta2x2 .
where p is the probability of the individual being male? idk

  This model is appropriate for our analysis since sex is a categorical variable and we would like to see how given information regarding an individual's socioeconomic conditions, if there is any bias towards their predicted sex. Assuming that there is little to no gender inequality, we expect to find that sex and socioeconomic status are independent. However, if we find that some socioeconomic factors are linked to sex, then we can infer that there is some element of bias within society that skews towards that result.

  For the purposes of our model, we chose several dependent variables such as income, educational attainment, and occupation that have historically been segregated strongly by sex. This data is categorical as a result of the survey methodology which was kept categorical for ease of aggregation. This unfortunately leads to some data points such as income (which would normally be quite continuous) as becoming categorical income ranges.

We fit our model using the built-in functions of R.

  Other potential models were considered for our analysis such as a Bayesian model as well as a classic linear model, but these were eliminated based on their weaknesses in appropriately modelling our data.

  We eliminated linear models as a possibility as they require that our response variable (the individual's sex) and the independent variables (varying socioeconomic factors) are linearly related. This also requires that the response variable be non-categorical which is clearly not the case for sex.

  Bayesian models require that we have information about the approximate distribution of the data (which we refer to as a prior) for the model. They are also best used when the prior is informative in some way as to the distribution that models the data. However since there are no clear trends from the GSS we cannot assume anything more than a uniform probability distribution for the distributions which is a non-informative prior. Thus, we do not use a Bayesian model.

## Discussion

```{r}
#If these graphs don't relate to our report, it is okay not to include
logit_feeling <- glm(is_male ~ feelings_life, data = gss, family = "binomial")
summary(logit_feeling)
# log(p/(1-p)) = 0.02197 - 0.024172*feelings_life

#Establishing the line for the logistic Regression
xfeelings_life <- seq(0, 10, 0.01)
yfeelings_life <- predict(logit_feeling, list(feelings_life = xfeelings_life),type="response")


plot(gss$feelings_life, gss$is_male,
     main="Logistic Regression on Female/ Male feeling about life", 
     xlab="Feeling about life as a whole (Scale from 1-10)",
     ylab="Female/ Male")
lines(xfeelings_life, yfeelings_life)


#Boxplot on feeling about life vs sex
gss %>%
  ggplot(aes(sex, feelings_life)) +
  geom_boxplot(colour = "black", fill = "cadetblue4") +
  labs(x = "sex",
       y = "Feeling about life (Scale from 1-10)",
       title = "Boxplot on Male/ Female feeling about life")

attach(gss)
lmod <- lm(feelings_life~total_children)
summary(lmod)

#plot on feeling about life vs total number of children in household
plot(gss$total_children, gss$feelings_life, 
     main="How total number of children in household affect feeling about life", 
     xlab="Total number of children",
     ylab="Feeling about life as a whole (Scale from 1-10)")
abline(lmod)
detach(gss)
```

```{r}
#Fitting Bayesian Model

#Not sure if it is my computer but this took very long to run
Bayesian_Model <- brm(formula = feelings_life~income_family, data = gss, seed = 666)
summary(Bayesian_Model)

mcmc_plot(Bayesian_Model)
mcmc_plot(Bayesian_Model, type = "hist")

#No Divergences to plot
mcmc_plot(Bayesian_Model, type = "trace")

posterior <- as.array(Bayesian_Model)
bayesplot::mcmc_intervals(posterior)
```


```{r}
#Logistic Regression model on sex depending on feeling about life, average hours worked and income.

logit_sex <- glm(is_male ~ feelings_life + avg_hrs_worked_rank + income_respondent_rank, data = gss)
summary(logit_sex)

# x1 = feelings_life, x2 = avg_hrs_worked_rank, x3 = income_respondent_rank
# log(p/(1-p)) = 0.02 - 0.01*x1 + 0.12*x2 + 0.04*x3

# So this basically tells us that on average have a higher feeling on life as a whole,
# male works more hours on average and have a higher income

#I am not really sure how to plot this, if no one does, we can just take it out
plot(logit_sex)


#plotting the variables separately 
attach(gss)
lmod_feelings_life <- lm(is_male~feelings_life)
summary(lmod_feelings_life)

lmod_avg_hrs_worked_rank <- lm(is_male~avg_hrs_worked_rank)
summary(lmod_avg_hrs_worked_rank)

lmod_income_respondent_rank <- lm(is_male~income_respondent_rank)
summary(lmod_income_respondent_rank)


plot(is_male ~ feelings_life)
abline(lmod_feelings_life)

plot(is_male ~ avg_hrs_worked_rank)
abline(lmod_avg_hrs_worked_rank)

plot(is_male ~ income_respondent_rank)
abline(lmod_income_respondent_rank)

detach(gss)
```





Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

#### Workspace set-up ####
library(janitor)
library(tidyverse)
library(readr)
library(dplyr)
library(stringr)
library(tidyr)

# Load the data dictionary and the raw data and correct the variable names
raw_data <- read_csv("gss.csv")
dict <- read_lines("gss_dict-1.txt", skip = 18) # skip is because of preamble content
# Now we need the labels because these are the actual responses that we need
labels_raw <- read_file("gss_labels-1.txt")


#### Set-up the dictionary ####
# What we want is a variable name and a variable definition
variable_descriptions <- as_tibble(dict) %>% 
  filter(value!="}") %>% 
  mutate(value = str_replace(value, ".+%[0-9].*f[ ]{2,}", "")) %>% 
  mutate(value = str_remove_all(value, "\"")) %>% 
  rename(variable_description = value) %>% 
  bind_cols(tibble(variable_name = colnames(raw_data)[-1]))
 
# Now we want a variable name and the possible values
labels_raw_tibble <- as_tibble(str_split(labels_raw, ";")[[1]]) %>% 
  filter(row_number()!=1) %>% 
  mutate(value = str_remove(value, "\nlabel define ")) %>% 
  mutate(value = str_replace(value, "[ ]{2,}", "XXX")) %>% 
  mutate(splits = str_split(value, "XXX")) %>% 
  rowwise() %>% 
  mutate(variable_name = splits[1], cases = splits[2]) %>% 
  mutate(cases = str_replace_all(cases, "\n [ ]{2,}", "")) %>%
  select(variable_name, cases) %>% 
  drop_na()

# Now we have the variable name and the different options e.g. age and 0-9, 10-19, etc.
labels_raw_tibble <- labels_raw_tibble %>% 
  mutate(splits = str_split(cases, "[ ]{0,}\"[ ]{0,}"))

# The function sets up the regex (I know, I know, but eh: https://xkcd.com/208/)
add_cw_text <- function(x, y){
  if(!is.na(as.numeric(x))){
    x_new <- paste0(y, "==", x,"~")
  }
  else{
    x_new <- paste0("\"",x,"\",")
  }
  return(x_new)
}

# The function will be in the row, but it'll get the job done
cw_statements <- labels_raw_tibble %>% 
  rowwise() %>% 
  mutate(splits_with_cw_text = list(modify(splits, add_cw_text, y = variable_name))) %>% 
  mutate(cw_statement = paste(splits_with_cw_text, collapse = "")) %>% 
  mutate(cw_statement = paste0("case_when(", cw_statement,"TRUE~\"NA\")")) %>% 
  mutate(cw_statement = str_replace(cw_statement, ",\"\",",",")) %>% 
  select(variable_name, cw_statement)
# So for every variable we now have a case_when() statement that will convert 
# from the number to the actual response.

# Just do some finally cleanup of the regex.
cw_statements <- 
  cw_statements %>% 
  mutate(variable_name = str_remove_all(variable_name, "\\r")) %>% 
  mutate(cw_statement = str_remove_all(cw_statement, "\\r"))


#### Apply that dictionary to the raw data ####
# Pull out a bunch of variables and then apply the case when statement for the categorical variables
gss <- raw_data %>% 
  select(CASEID, 
         agedc, 
         achd_1c, 
         achdmpl, 
         totchdc, 
         acu0c,
         agema1c,
         achb1c,
         rsh_131a,
         arretwk,
         slm_01, 
         sex, 
         brthcan, 
         brthfcan,
         brthmcan,
         brthmacr,
         brthprvc,
         yrarri,
         prv, 
         region, 
         luc_rst, 
         marstat, 
         amb_01, 
         vismin, 
         alndimmg,
         bpr_16, 
         bpr_19,
         ehg3_01b, 
         odr_10, 
         livarr12, 
         dwelc, 
         hsdsizec,
         brthpcan,
         brtpprvc, 
         visminpr,
         rsh_125a, 
         eop_200,
         uhw_16gr,
         lmam_01, 
         acmpryr,
         srh_110,
         srh_115,
         religflg, 
         rlr_110,
         lanhome, 
         lan_01,
         famincg2, 
         ttlincg2, 
         noc1610, 
         cc_20_1,
         cc_30_1,
         ccmoc1c,
         cor_031,
         cor_041,
         cu0rnkc,
         pr_cl,
         chh0014c,
         nochricc,
         grndpa,
         gparliv,
         evermar,
         ma0_220,
         nmarevrc,
         ree_02,
         rsh_131b,
         rto_101,
         rto_110,
         rto_120,
         rtw_300,
         sts_410,
         csp_105,
         csp_110a,
         csp_110b,
         csp_110c,
         csp_110d,
         csp_160,
         fi_110) %>% 
  mutate_at(vars(agedc:fi_110), .funs = funs(ifelse(.>=96, NA, .))) %>% 
  mutate_at(.vars = vars(sex:fi_110),
            .funs = funs(eval(parse(text = cw_statements %>%
                                      filter(variable_name==deparse(substitute(.))) %>%
                                      select(cw_statement) %>%
                                      pull()))))

# Fix the names
gss <- gss %>% 
  clean_names() %>% 
  rename(age = agedc,
         age_first_child = achd_1c,
         age_youngest_child_under_6 = achdmpl,
         total_children = totchdc,
         age_start_relationship = acu0c,
         age_at_first_marriage = agema1c,
         age_at_first_birth = achb1c,
         distance_between_houses = rsh_131a,
         age_youngest_child_returned_work = arretwk,
         feelings_life = slm_01,
         sex = sex,
         place_birth_canada = brthcan,
         place_birth_father = brthfcan,
         place_birth_mother = brthmcan,
         place_birth_macro_region = brthmacr,
         place_birth_province = brthprvc,
         year_arrived_canada = yrarri,
         province = prv,
         region = region,
         pop_center = luc_rst,
         marital_status = marstat,
         aboriginal = amb_01,
         vis_minority = vismin,
         age_immigration = alndimmg,
         landed_immigrant = bpr_16,
         citizenship_status = bpr_19,
         education = ehg3_01b,
         own_rent = odr_10,
         living_arrangement = livarr12,
         hh_type = dwelc,
         hh_size = hsdsizec,
         partner_birth_country = brthpcan,
         partner_birth_province = brtpprvc,
         partner_vis_minority = visminpr,
         partner_sex = rsh_125a,
         partner_education = eop_200,
         average_hours_worked = uhw_16gr,
         worked_last_week = lmam_01,
         partner_main_activity = acmpryr,
         self_rated_health = srh_110,
         self_rated_mental_health = srh_115,
         religion_has_affiliation = religflg,
         regilion_importance = rlr_110,
         language_home = lanhome,
         language_knowledge = lan_01,
         income_family = famincg2,
         income_respondent = ttlincg2,
         occupation = noc1610,
         childcare_regular = cc_20_1,
         childcare_type = cc_30_1,
         childcare_monthly_cost = ccmoc1c,
         ever_fathered_child = cor_031,
         ever_given_birth = cor_041,
         number_of_current_union = cu0rnkc,
         lives_with_partner = pr_cl,
         children_in_household = chh0014c,
         number_total_children_intention = nochricc,
         has_grandchildren = grndpa,
         grandparents_still_living = gparliv,
         ever_married = evermar,
         current_marriage_is_first = ma0_220,
         number_marriages = nmarevrc,
         religion_participation = ree_02,
         partner_location_residence = rsh_131b,
         full_part_time_work = rto_101,
         time_off_work_birth = rto_110,
         reason_no_time_off_birth = rto_120,
         returned_same_job = rtw_300,
         satisfied_time_children = sts_410,
         provide_or_receive_fin_supp = csp_105,
         fin_supp_child_supp = csp_110a,
         fin_supp_child_exp = csp_110b,
         fin_supp_lump = csp_110c,
         fin_supp_other = csp_110d,
         fin_supp_agreement = csp_160,
         future_children_intention = fi_110) 

#### Clean up ####
gss <- gss %>% 
  mutate_at(vars(age:future_children_intention), 
            .funs = funs(ifelse(.=="Valid skip"|.=="Refusal"|.=="Not stated", "NA", .))) 

gss <- gss %>% 
  mutate(is_male = ifelse(sex=="Male", 1, 0)) 

gss <- gss %>% 
  mutate_at(vars(fin_supp_child_supp:fin_supp_other), .funs = funs(case_when(
    .=="Yes"~1,
    .=="No"~0,
    .=="NA"~as.numeric(NA)
  )))

main_act <- raw_data %>% 
  mutate(main_activity = case_when(
    mpl_105a=="Yes"~ "Working at a paid job/business",
    mpl_105b=="Yes" ~ "Looking for paid work",
    mpl_105c=="Yes" ~ "Going to school",
    mpl_105d=="Yes" ~ "Caring for children",
    mpl_105e=="Yes" ~ "Household work", 
    mpl_105i=="Yes" ~ "Other", 
    TRUE~ "NA")) %>% 
  select(main_activity) %>% 
  pull()

age_diff <- raw_data %>% 
  select(marstat, aprcu0c, adfgrma0) %>% 
  mutate_at(.vars = vars(aprcu0c:adfgrma0),
            .funs = funs(eval(parse(text = cw_statements %>%
                                      filter(variable_name==deparse(substitute(.))) %>%
                                      select(cw_statement) %>%
                                      pull())))) %>% 
  mutate(age_diff = ifelse(marstat=="Living common-law", aprcu0c, adfgrma0)) %>% 
  mutate_at(vars(age_diff), .funs = funs(ifelse(.=="Valid skip"|.=="Refusal"|.=="Not stated", "NA", .))) %>% 
  select(age_diff) %>% 
  pull()

gss <- gss %>% mutate(main_activity = main_act, age_diff = age_diff)

# Change some from strings into numbers
gss <- gss %>% 
  rowwise() %>% 
  mutate(hh_size = str_remove(string = hh_size, pattern = "\\ .*")) %>% 
  mutate(hh_size = case_when(
    hh_size=="One" ~ 1,
    hh_size=="Two" ~ 2,
    hh_size=="Three" ~ 3,
    hh_size=="Four" ~ 4,
    hh_size=="Five" ~ 5,
    hh_size=="Six" ~ 6
  )) 

gss <- gss %>% 
  rowwise() %>% 
  mutate(number_marriages = str_remove(string = number_marriages, pattern = "\\ .*")) %>% 
  mutate(number_marriages = case_when(
    number_marriages=="No" ~ 0,
    number_marriages=="One" ~ 1,
    number_marriages=="Two" ~ 2,
    number_marriages=="Three" ~ 3,
    number_marriages=="Four" ~ 4
  )) 

gss <- gss %>% 
  rowwise() %>% 
  mutate(number_total_children_known = ifelse(number_total_children_intention=="Don't know"|number_total_children_intention=="NA", 0, 1)) %>% 
  mutate(number_total_children_intention = str_remove(string = number_total_children_intention, pattern = "\\ .*")) %>% 
  mutate(number_total_children_intention = case_when(
    number_total_children_intention=="None" ~ 0,
    number_total_children_intention=="One" ~ 1,
    number_total_children_intention=="Two" ~ 2,
    number_total_children_intention=="Three" ~ 3,
    number_total_children_intention=="Four" ~ 4,
    number_total_children_intention=="Don't" ~ as.numeric(NA)
  )) 

write_csv(gss, "gss.csv")
```
